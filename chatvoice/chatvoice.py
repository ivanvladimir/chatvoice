#p!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Ivan Vladimir Meza Ruiz 2018
# GPL 3.0

# imports
import faulthandler

faulthandler.enable(all_threads=True)
from click_option_group import optgroup
import rich_click as click
from rich import print
import sys
import configparser
import os.path

# local imports
from .conversation import Conversation
from .config import set_config, get_config
#from .audio import audio_close, audio_devices, list_voices

# Main service
config = configparser.ConfigParser()
CONFIG_SECTION = "DEFAULT"


@click.group()
@click.option("--config-filename", type=click.Path(), default="config.ini")
@click.option("--config-section", type=str, default="DEFAULT")
@click.option("-v", "--verbose", is_flag=True, help="Verbose mode")
@click.pass_context
def chatvoice(
    ctx, config_filename, config_section="DEFAULT", verbose=False
):
    global config
    global CONFIG_SECTION
    section = "DEFAULT"
    ctx.ensure_object(dict)
    if os.path.exists(config_filename):
        config.read(config_filename)
    else:
        print(f"[red]Error no config file '{config_file}'[/red]")
        sys.exit()
    if config_section in config:
        section = config_section
    else:
        print(f"[red]Error no section '{config_section}' present in '{config_filename}'[/red]")
        sys.exit()
    CONFIG_SECTION = section
    ctx.obj["config"] = config
    ctx.obj["config_section"] = section
    ctx.obj["verbose"] = verbose


@chatvoice.command()
@click.option("--conversation-file", type=click.Path(exists=True))
@click.option("--print-config", type=str, is_flag=True, help="Print values of config")
@click.option("--devices", is_flag=True, help="List audio devices")
@click.option("--local-tts-voices", is_flag=True, help="List voices from local TTS")
@click.option(
    "--google-tts-languages", is_flag=True, help="List languages for google languages"
)
@click.pass_context
def info(
    ctx,
    conversation_file,
    devices,
    print_config,
    local_tts_voices,
    google_tts_languages,
):
    """Print information fo the system"""
    if devices:
        print(audio_devices())
    if print_config:
        for sec in config:
            print(f"[{sec}]")
            for key, val in config[sec].items():
                print(f"{key}={val}")
            print()
    if local_tts_voices:
        list_voices(engine="local")
    if google_tts_languages:
        list_voices(engine="google")


@chatvoice.command()
@click.argument("conversation-file", type=click.Path(exists=True))
@optgroup.group("Paths", help="Paths to auxiliary files")
@optgroup.option(
    "--audios-dir",
    type=click.Path(),
    help="Prefix directory for audios",
)
@optgroup.option(
    "--speech-recognition-dir",
    type=click.Path(),
    help="Directory for audios for speech recognition",
)
@optgroup.option(
    "--tts-dir",
    type=click.Path(),
    help="Directory for audios for tts",
)
@optgroup.option(
    "--is-filename",
    type=click.Path(),
    help="File to save the Information State (remember) filename",
)
@optgroup.option(
    "--audio-tts-db",
    type=click.Path(),
    help="File to store information about the audios generated by the tts",
)
@optgroup.group("Conversation", help="Conversation files")
@optgroup.option(
    "--generate-all-tts",
    is_flag=True,
    help="During tts generate all audios, do not use the database",
)
@optgroup.option(
    "--remember-all",
    is_flag=True,
    help="Remember all slots from conversation",
)
@optgroup.option(
    "--erase_memory",
    is_flag=True,
    help="Erase memory",
)
@optgroup.group("Speech", help="Options to control speech processing")
@optgroup.option(
    "--speech-recognition",
    is_flag=True,
    help="**DEACTIVATED** Activate speech recognition",
)
@optgroup.option(
    "--tts",
    type=click.Choice(["local", "google"], case_sensitive=False),
    help="Select the tts to use",
)
@optgroup.option(
    "--local-tts-voice",
    type=str,
    help="Use espeak local tts",
)
@optgroup.option(
    "--google-tts-language",
    type=str,
    help="Use espeak local tts",
)
@optgroup.group("Audio", help="Options to control audio")
@optgroup.option(
    "--samplerate",
    type=int,
    help="Samplerate",
)
@optgroup.option(
    "--num-channels",
    type=int,
    help="Number of channels microphone",
)
@optgroup.option(
    "--device",
    type=int,
    help="Device number to connect audio",
)
@optgroup.option(
    "--aggressiveness",
    is_flag=True,
    help="VAD aggressiveness",
)

@click.pass_context
def console(ctx, conversation_file=None, **args):
    """Lauches a chatvoice for console"""
    CONFIG = dict(config[ctx.obj["config_section"]])
    CONFIG.update({k:v for k,v in args.items() if v})
    CONFIG["main_path"] = os.path.dirname(conversation_file)
    CONFIG["verbose"] = ctx.obj["verbose"]
    # Temporarily not working
    CONFIG["speech_recognition"] = False

    # Main conversation
    conversation = Conversation(filename=conversation_file, **CONFIG)
    conversation.execute()

@chatvoice.command()
@click.argument(
    "conversations-dir", type=click.Path(exists=True)
)
@optgroup.group("Server", help="Server configuration")
@optgroup.option(
    "--host",
    type=str,
    help="IP for service",
)
@optgroup.option(
    "--port",
    type=int,
    help="Port url",
)
@optgroup.option(
    "--use_hypercorn",
    is_flag=True,
    default=False,
    help="User hypercorn instead of uvicorn [False]",
)


@optgroup.option(
    "--reload",
    is_flag=True,
    default=False,
    help="Reload webservice uvicorn [False]",
)
@optgroup.option(
    "--workers",
    type=int,
    help="Number of workers for uvicorn [4]",
)
@optgroup.group("Paths", help="Paths to auxiliary files")
@optgroup.option(
    "--audios-dir",
    type=click.Path(),
    help="Prefix directory for audios",
)
@optgroup.option(
    "--speech-recognition-dir",
    type=click.Path(),
    help="Directory for audios for speech recognition",
)
@optgroup.option(
    "--tts-dir",
    type=click.Path(),
    help="Directory for audios for tts",
)
@optgroup.option(
    "--is-filename",
    type=click.Path(),
    help="File to save the Information State (remember) filename",
)
@optgroup.option(
    "--audio-tts-db",
    type=click.Path(),
    help="File to store information about the audios generated by the tts",
)
@optgroup.group("Conversation", help="Conversation files")
@optgroup.option(
    "--generate-all-tts",
    is_flag=True,
    help="During tts generate all audios, do not use the database",
)
@optgroup.option(
    "--remember-all",
    is_flag=True,
    help="Remember all slots from conversation",
)
@optgroup.option(
    "--erase_memory",
    is_flag=True,
    help="Erase memory",
)
@optgroup.group("Speech", help="Options to control speech processing")
@optgroup.option(
    "--speech-recognition",
    is_flag=True,
    help="**DEACTIVATED** Activate speech recognition",
)
@optgroup.option(
    "--tts",
    type=click.Choice(["local", "google"], case_sensitive=False),
    help="Select the tts to use",
)
@optgroup.option(
    "--local-tts-voice",
    type=str,
    help="Use espeak local tts",
)
@optgroup.option(
    "--google-tts-language",
    type=str,
    help="Use espeak local tts",
)
@optgroup.group("Audio", help="Options to control audio")
@optgroup.option(
    "--samplerate",
    type=int,
    help="Samplerate",
)
@optgroup.option(
    "--num-channels",
    type=int,
    help="Number of channels microphone",
)
@optgroup.option(
    "--device",
    type=int,
    help="Device number to connect audio",
)
@optgroup.option(
    "--aggressiveness",
    is_flag=True,
    help="VAD aggressiveness",
)
@click.pass_context
def server(ctx, conversations_dir, **args):
    """Lauches a chatvoice for console"""
    global config
    import threading

    CONFIG = dict(config[ctx.obj["config_section"]])
    CONFIG.update({k:v for k,v in args.items() if v})
    CONFIG["verbose"] = ctx.obj["verbose"]
    CONFIG["conversations_dir"] = conversations_dir
    # Temporarily speech recognition not working
    CONFIG["speech_recognition"] = False
    set_config(**CONFIG)

    # Main conversation
    # conversation = Conversation(
    #        filename=ctx.obj["conversation_file"],
    #        **CONFIG)

    # Thread for conversation
    # t = threading.Thread(target=conversation.execute)
    # conversation.set_thread(t)

    if not 'use_hypercorn' in CONFIG:
        import uvicorn
        uvicorn.run(
            "chatvoice.webservice:create_app",
            host=CONFIG["host"],
            port=int(CONFIG["port"]),
            workers=int(CONFIG["workers"]),
            factory=True,
            lifespan="off",  # TODO: figure out why it fails when on
            reload=True,
        )  # CONFIG['reload'])
    else:
        import trio
        from hypercorn.config import Config
        from hypercorn.trio import serve
        from .webservice import create_app

        config = Config()
        config.bind = [f"{CONFIG['host']}:{CONFIG['port']}"]
        config.workers = int(CONFIG["workers"])
        config.websocket_ping_interval = None
        trio.run(serve,create_app(), config)



if __name__ == "__main__":
    chatvoice(obj={})
